name: Deploy (reusable)

on:
  workflow_call:
    inputs:
      GIT_BRANCH:
        required: false
        type: string
      REPO_URL:
        required: false
        type: string
      SERVER_HOST:
        required: true
        type: string
      SERVER_USER:
        required: true
        type: string
      PROJECT_PATH:
        required: true
        type: string
      PROJECT_NAME:
        required: true
        type: string
      DOMAIN_NAME:
        required: true
        type: string
      TRAEFIK_NETWORK:
        required: true
        type: string
      TRAEFIK_ENTRYPOINT:
        required: false
        type: string
      PORTAINER_BASIC_AUTH_USER:
        required: false
        type: string
    secrets:
      SSH_PRIVATE_KEY:
        required: true
      REPO_SSH_KEY:
        required: false
      PORTAINER_BASIC_AUTH_PASSWORD:
        required: false

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      GIT_BRANCH: ${{ inputs.GIT_BRANCH }}
      REPO_URL: ${{ inputs.REPO_URL }}
      SERVER_HOST: ${{ inputs.SERVER_HOST }}
      SERVER_USER: ${{ inputs.SERVER_USER }}
      SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
      REPO_SSH_KEY: ${{ secrets.REPO_SSH_KEY }}
      PROJECT_PATH: ${{ inputs.PROJECT_PATH }}
      PROJECT_NAME: ${{ inputs.PROJECT_NAME }}
      DOMAIN_NAME: ${{ inputs.DOMAIN_NAME }}
      TRAEFIK_NETWORK: ${{ inputs.TRAEFIK_NETWORK }}
      TRAEFIK_ENTRYPOINT: ${{ inputs.TRAEFIK_ENTRYPOINT }}
      PORTAINER_BASIC_AUTH_USER: ${{ inputs.PORTAINER_BASIC_AUTH_USER }}
      PORTAINER_BASIC_AUTH_PASSWORD: ${{ secrets.PORTAINER_BASIC_AUTH_PASSWORD }}
    steps:
      - name: Validate required secrets
        run: |
          set -euo pipefail
          missing=0
          for key in SERVER_HOST SERVER_USER SSH_PRIVATE_KEY PROJECT_PATH PROJECT_NAME DOMAIN_NAME TRAEFIK_NETWORK REPO_URL; do
            if [ -z "${!key}" ]; then
              echo "Missing required secret: $key" >&2
              missing=1
            fi
          done
          if [ "$missing" -ne 0 ]; then
            exit 1
          fi

      - name: Prepare SSH-safe env
        id: prepare_ssh_env
        run: |
          set -euo pipefail
          # Passwords can contain characters that break SSH env passing; encode as URL-safe base64 (no '+', '/', '=').
          user_b64="$(printf '%s' "${PORTAINER_BASIC_AUTH_USER:-}" | base64 | tr -d '\n' | sed 'y:+/:-_:' | tr -d '=')"
          pass_b64="$(printf '%s' "${PORTAINER_BASIC_AUTH_PASSWORD:-}" | base64 | tr -d '\n' | sed 'y:+/:-_:' | tr -d '=')"
          printf '%s\n' "user_b64=$user_b64" >> "$GITHUB_OUTPUT"
          printf '%s\n' "pass_b64=$pass_b64" >> "$GITHUB_OUTPUT"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          envs: GIT_BRANCH,REPO_URL,REPO_SSH_KEY,PROJECT_PATH,PROJECT_NAME,DOMAIN_NAME,TRAEFIK_NETWORK,TRAEFIK_ENTRYPOINT
          script: |
            set -euo pipefail

            # Pass BasicAuth credentials via inline script variables (avoids env transport corruption).
            PORTAINER_BASIC_AUTH_USER_B64='${{ steps.prepare_ssh_env.outputs.user_b64 }}'
            PORTAINER_BASIC_AUTH_PASSWORD_B64='${{ steps.prepare_ssh_env.outputs.pass_b64 }}'

            if ! command -v git >/dev/null 2>&1; then
              echo "git is not installed on the server" >&2
              exit 1
            fi

            if ! command -v docker >/dev/null 2>&1; then
              echo "docker is not installed on the server" >&2
              exit 1
            fi

            COMPOSE_BIN="docker compose"
            if ! docker compose version >/dev/null 2>&1; then
              if command -v docker-compose >/dev/null 2>&1; then
                COMPOSE_BIN="docker-compose"
              else
                echo "Docker Compose is not available (neither 'docker compose' nor 'docker-compose')" >&2
                exit 1
              fi
            fi

            if [ -z "${PROJECT_PATH:-}" ]; then
              echo "PROJECT_PATH is empty" >&2
              exit 1
            fi

            if [ -z "${REPO_URL:-}" ]; then
              echo "REPO_URL is empty" >&2
              exit 1
            fi

            branch="${GIT_BRANCH:-}"
            if [ -z "$branch" ]; then branch="main"; fi

            clone_url="$REPO_URL"
            if [ -n "${REPO_SSH_KEY:-}" ]; then
              mkdir -p "$HOME/.ssh"
              chmod 700 "$HOME/.ssh"
              git_ssh_key_path="$HOME/.ssh/repo_deploy_key"
              printf '%s\n' "$REPO_SSH_KEY" > "$git_ssh_key_path"
              chmod 600 "$git_ssh_key_path"
              touch "$HOME/.ssh/known_hosts"
              chmod 600 "$HOME/.ssh/known_hosts"
              if ! ssh-keygen -F github.com >/dev/null 2>&1; then
                ssh-keyscan -H github.com >> "$HOME/.ssh/known_hosts" 2>/dev/null || true
              fi
              export GIT_SSH_COMMAND="ssh -i $git_ssh_key_path -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes"

              ssh_url=""
              case "$REPO_URL" in
                git@github.com:*)
                  ssh_url="$REPO_URL"
                  ;;
                https://github.com/*)
                  repo_path="${REPO_URL#https://github.com/}"
                  repo_path="${repo_path%.git}"
                  ssh_url="git@github.com:${repo_path}.git"
                  ;;
              esac
              if [ -z "$ssh_url" ]; then
                echo "When REPO_SSH_KEY is set, REPO_URL must be a GitHub URL (https://github.com/<owner>/<repo>.git) or a git@github.com:<owner>/<repo>.git URL" >&2
                exit 1
              fi
              clone_url="$ssh_url"
            fi

            if [ ! -d "$PROJECT_PATH" ]; then
              parent_dir="$(dirname "$PROJECT_PATH")"
              mkdir -p "$parent_dir"
              git clone --branch "$branch" "$clone_url" "$PROJECT_PATH"
            fi

            if [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
              if [ -z "$(ls -A "$PROJECT_PATH" 2>/dev/null || true)" ]; then
                rmdir "$PROJECT_PATH" 2>/dev/null || true
                parent_dir="$(dirname "$PROJECT_PATH")"
                mkdir -p "$parent_dir"
                git clone --branch "$branch" "$clone_url" "$PROJECT_PATH"
              else
                echo "Not a git repository: $PROJECT_PATH (missing .git)" >&2
                echo "Fix: set PROJECT_PATH to the repo root, or delete this directory and re-run deploy." >&2
                exit 1
              fi
            fi

            cd "$PROJECT_PATH"

            if [ ! -d .git ]; then
              echo "Not a git repository: $PROJECT_PATH (missing .git)" >&2
              exit 1
            fi

            if [ ! -f docker-compose.yml ]; then
              echo "docker-compose.yml not found in $PROJECT_PATH" >&2
              echo "Fix: ensure the repository was cloned correctly and PROJECT_PATH points to its root." >&2
              exit 1
            fi

            git remote set-url origin "$clone_url" || true
            if ! git pull origin "$branch"; then
              echo "git pull failed. If this is a private repository, set REPO_SSH_KEY (GitHub Deploy Key private key) in CI secrets." >&2
              exit 1
            fi

            if [ -z "${TRAEFIK_NETWORK:-}" ]; then
              echo "TRAEFIK_NETWORK is empty" >&2
              exit 1
            fi

            if ! docker network inspect "$TRAEFIK_NETWORK" >/dev/null 2>&1; then
              echo "Traefik network '$TRAEFIK_NETWORK' does not exist on the server" >&2
              echo "Create it first, e.g.: docker network create $TRAEFIK_NETWORK" >&2
              exit 1
            fi

            # Optional: generate Traefik Basic Auth override from user+password.
            decode_b64_or_raw() {
              input="${1:-}"
              if [ -z "$input" ]; then
                printf '%s' ""
                return 0
              fi
              # Accept both standard base64 and URL-safe base64 (no padding).
              cleaned="$(printf '%s' "$input" | tr -d '\n\r' | sed 'y:-_:+/:' )"
              case $((${#cleaned} % 4)) in
                0) : ;;
                2) cleaned="${cleaned}==" ;;
                3) cleaned="${cleaned}=" ;;
                1) cleaned="" ;; # invalid length
              esac

              if [ -n "$cleaned" ]; then
                # Prefer decoding inside a container (doesn't rely on host base64/python).
                if command -v docker >/dev/null 2>&1; then
                  if ! docker image inspect httpd:alpine >/dev/null 2>&1; then
                    docker pull -q httpd:alpine >/dev/null 2>&1 || true
                  fi
                  if docker image inspect httpd:alpine >/dev/null 2>&1; then
                    decoded="$(printf '%s' "$cleaned" | docker run --rm -i httpd:alpine sh -c 'base64 -d 2>/dev/null' 2>/dev/null || true)"
                    if [ -n "$decoded" ]; then
                      printf '%s' "$decoded"
                      return 0
                    fi
                  fi
                fi
                # Try GNU coreutils base64.
                if decoded="$(printf '%s' "$cleaned" | base64 --decode 2>/dev/null)"; then
                  printf '%s' "$decoded"
                  return 0
                fi
                # Try BusyBox / BSD style.
                if decoded="$(printf '%s' "$cleaned" | base64 -d 2>/dev/null)"; then
                  printf '%s' "$decoded"
                  return 0
                fi
                # Fallback: python3 (if available).
                if command -v python3 >/dev/null 2>&1; then
                  if decoded="$(B64="$cleaned" python3 -c 'import os,base64; s=os.environ.get("B64",""); print(base64.b64decode(s).decode("utf-8"), end="")')"; then
                    printf '%s' "$decoded"
                    return 0
                  fi
                fi
              fi
              # Fallback: treat the value as already-decoded raw text.
              printf '%s' "$input"
            }

            PORTAINER_BASIC_AUTH_USER=""
            PORTAINER_BASIC_AUTH_PASSWORD=""
            if [ -n "${PORTAINER_BASIC_AUTH_USER_B64:-}" ]; then
              PORTAINER_BASIC_AUTH_USER="$(decode_b64_or_raw "$PORTAINER_BASIC_AUTH_USER_B64" | tr -d '\r' | sed -n '/./{p;q;}')"
            fi
            if [ -n "${PORTAINER_BASIC_AUTH_PASSWORD_B64:-}" ]; then
              PORTAINER_BASIC_AUTH_PASSWORD="$(decode_b64_or_raw "$PORTAINER_BASIC_AUTH_PASSWORD_B64" | tr -d '\r' | sed -n '/./{p;q;}')"
            fi

            if [ -n "$PORTAINER_BASIC_AUTH_USER" ] && [ -n "$PORTAINER_BASIC_AUTH_PASSWORD" ]; then
              if ! docker image inspect httpd:alpine >/dev/null 2>&1; then
                docker pull -q httpd:alpine
              fi
              BASIC_AUTH_HTPASSWD_LINE="$(docker run --rm httpd:alpine htpasswd -Bbn "$PORTAINER_BASIC_AUTH_USER" "$PORTAINER_BASIC_AUTH_PASSWORD" | head -n 1)"
              # docker compose treats '$' as interpolation marker in compose files; escape as '$$'
              BASIC_AUTH_HTPASSWD_LINE_COMPOSE="$(printf '%s' "$BASIC_AUTH_HTPASSWD_LINE" | sed 's/\$/\$\$/g')"

              {
                echo "# Generated by CI (Traefik Basic Auth)"
                echo "services:"
                echo "  portainer:"
                echo "    labels:"
                echo "      - \"traefik.http.routers.${PROJECT_NAME}.middlewares=${PROJECT_NAME}-auth\""
                echo "      - \"traefik.http.middlewares.${PROJECT_NAME}-auth.basicauth.users=${BASIC_AUTH_HTPASSWD_LINE_COMPOSE}\""
              } > docker-compose.override.yml

              if [ -s docker-compose.override.yml ]; then
                echo "Traefik BasicAuth: enabled (docker-compose.override.yml written)"
              else
                echo "Traefik BasicAuth: ERROR (override file not written)" >&2
                exit 1
              fi
            else
              # If creds are not set, ensure CI-managed auth is disabled.
              if [ -f docker-compose.override.yml ] && head -n 1 docker-compose.override.yml | grep -q '^# Generated by CI (Traefik Basic Auth)$'; then
                rm -f docker-compose.override.yml
              fi
              echo "Traefik BasicAuth: disabled (missing user or password)"
            fi

            tmp="$(mktemp)"
            if [ -f .env ]; then
              grep -vE '^(PROJECT_NAME|DOMAIN_NAME|TRAEFIK_NETWORK|TRAEFIK_ENTRYPOINT)=' .env > "$tmp" || true
            fi

            : > .env
            printf '%s\n' "PROJECT_NAME=$PROJECT_NAME" >> .env
            printf '%s\n' "DOMAIN_NAME=$DOMAIN_NAME" >> .env
            printf '%s\n' "TRAEFIK_NETWORK=$TRAEFIK_NETWORK" >> .env

            if [ -n "${TRAEFIK_ENTRYPOINT:-}" ]; then
              printf '%s\n' "TRAEFIK_ENTRYPOINT=$TRAEFIK_ENTRYPOINT" >> .env
            fi

            if [ -s "$tmp" ]; then
              cat "$tmp" >> .env
            fi
            rm -f "$tmp"

            $COMPOSE_BIN up -d
            docker image prune -f
