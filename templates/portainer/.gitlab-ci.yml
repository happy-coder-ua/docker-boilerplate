stages:
  - deploy

deploy:
  stage: deploy
  image: alpine:latest
  rules:
    - if: '$SERVER_HOST && $SERVER_USER && $SSH_PRIVATE_KEY && $PROJECT_PATH && $PROJECT_NAME && $DOMAIN_NAME && $TRAEFIK_NETWORK && $REPO_URL'
      when: on_success
    - when: never
  before_script:
    - 'which ssh-agent || ( apk add --update openssh git docker-cli )'
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan $SERVER_HOST >> ~/.ssh/known_hosts
  script:
    - |
      set -euo pipefail

      : "${SERVER_HOST:?SERVER_HOST is required}"
      : "${SERVER_USER:?SERVER_USER is required}"
      : "${SSH_PRIVATE_KEY:?SSH_PRIVATE_KEY is required}"
      : "${PROJECT_PATH:?PROJECT_PATH is required}"
      : "${PROJECT_NAME:?PROJECT_NAME is required}"
      : "${DOMAIN_NAME:?DOMAIN_NAME is required}"
      : "${TRAEFIK_NETWORK:?TRAEFIK_NETWORK is required}"
      : "${REPO_URL:?REPO_URL is required}"

      branch="${GIT_BRANCH:-${CI_COMMIT_BRANCH:-main}}"

      PROJECT_NAME_B64="$(printf '%s' "$PROJECT_NAME" | base64 | tr -d '\n')"
      DOMAIN_NAME_B64="$(printf '%s' "$DOMAIN_NAME" | base64 | tr -d '\n')"
      TRAEFIK_NETWORK_B64="$(printf '%s' "$TRAEFIK_NETWORK" | base64 | tr -d '\n')"
      TRAEFIK_ENTRYPOINT_B64="$(printf '%s' "${TRAEFIK_ENTRYPOINT:-}" | base64 | tr -d '\n')"
      REPO_URL_B64="$(printf '%s' "$REPO_URL" | base64 | tr -d '\n')"
      PROJECT_PATH_B64="$(printf '%s' "$PROJECT_PATH" | base64 | tr -d '\n')"
      BRANCH_B64="$(printf '%s' "$branch" | base64 | tr -d '\n')"
      PORTAINER_BASIC_AUTH_USER_B64="$(printf '%s' "${PORTAINER_BASIC_AUTH_USER:-}" | base64 | tr -d '\n' | sed 'y:+/:-_:' | tr -d '=')"
      PORTAINER_BASIC_AUTH_PASSWORD_B64="$(printf '%s' "${PORTAINER_BASIC_AUTH_PASSWORD:-}" | base64 | tr -d '\n' | sed 'y:+/:-_:' | tr -d '=')"

      REPO_SSH_KEY_B64=""
      if [ -n "${REPO_SSH_KEY:-}" ]; then
        REPO_SSH_KEY_B64="$(printf '%s' "$REPO_SSH_KEY" | base64 | tr -d '\n')"
      fi

      ssh "$SERVER_USER@$SERVER_HOST" \
        "PROJECT_NAME_B64='$PROJECT_NAME_B64' DOMAIN_NAME_B64='$DOMAIN_NAME_B64' TRAEFIK_NETWORK_B64='$TRAEFIK_NETWORK_B64' TRAEFIK_ENTRYPOINT_B64='$TRAEFIK_ENTRYPOINT_B64' REPO_URL_B64='$REPO_URL_B64' PROJECT_PATH_B64='$PROJECT_PATH_B64' BRANCH_B64='$BRANCH_B64' PORTAINER_BASIC_AUTH_USER_B64='$PORTAINER_BASIC_AUTH_USER_B64' PORTAINER_BASIC_AUTH_PASSWORD_B64='$PORTAINER_BASIC_AUTH_PASSWORD_B64' REPO_SSH_KEY_B64='$REPO_SSH_KEY_B64'" \
        'sh -s' <<'REMOTE'
      set -euo pipefail

      PROJECT_NAME="$(printf '%s' "$PROJECT_NAME_B64" | base64 -d)"
      DOMAIN_NAME="$(printf '%s' "$DOMAIN_NAME_B64" | base64 -d)"
      TRAEFIK_NETWORK="$(printf '%s' "$TRAEFIK_NETWORK_B64" | base64 -d)"
      TRAEFIK_ENTRYPOINT="$(printf '%s' "$TRAEFIK_ENTRYPOINT_B64" | base64 -d)"
      REPO_URL="$(printf '%s' "$REPO_URL_B64" | base64 -d)"
      PROJECT_PATH="$(printf '%s' "$PROJECT_PATH_B64" | base64 -d)"
      branch="$(printf '%s' "$BRANCH_B64" | base64 -d)"
      # Optional: generate Traefik Basic Auth override from user+password.
      decode_b64_or_raw() {
        input="${1:-}"
        if [ -z "$input" ]; then
          printf '%s' ""
          return 0
        fi
        cleaned="$(printf '%s' "$input" | tr -d '\n\r' | sed 'y:-_:+/:' )"
        case $((${#cleaned} % 4)) in
          0) : ;;
          2) cleaned="${cleaned}==" ;;
          3) cleaned="${cleaned}=" ;;
          1) cleaned="" ;;
        esac
        if [ -n "$cleaned" ]; then
          if command -v docker >/dev/null 2>&1; then
            if ! docker image inspect httpd:alpine >/dev/null 2>&1; then
              docker pull -q httpd:alpine >/dev/null 2>&1 || true
            fi
            if docker image inspect httpd:alpine >/dev/null 2>&1; then
              decoded="$(printf '%s' "$cleaned" | docker run --rm -i httpd:alpine sh -c 'base64 -d 2>/dev/null' 2>/dev/null || true)"
              if [ -n "$decoded" ]; then
                printf '%s' "$decoded"
                return 0
              fi
            fi
          fi
          if decoded="$(printf '%s' "$cleaned" | base64 --decode 2>/dev/null)"; then
            printf '%s' "$decoded"
            return 0
          fi
          if decoded="$(printf '%s' "$cleaned" | base64 -d 2>/dev/null)"; then
            printf '%s' "$decoded"
            return 0
          fi
        fi
        printf '%s' "$input"
      }

      PORTAINER_BASIC_AUTH_USER=""
      PORTAINER_BASIC_AUTH_PASSWORD=""
      if [ -n "${PORTAINER_BASIC_AUTH_USER_B64:-}" ]; then
        PORTAINER_BASIC_AUTH_USER="$(decode_b64_or_raw "$PORTAINER_BASIC_AUTH_USER_B64" | tr -d '\r' | sed -n '/./{p;q;}')"
      fi
      if [ -n "${PORTAINER_BASIC_AUTH_PASSWORD_B64:-}" ]; then
        PORTAINER_BASIC_AUTH_PASSWORD="$(decode_b64_or_raw "$PORTAINER_BASIC_AUTH_PASSWORD_B64" | tr -d '\r' | sed -n '/./{p;q;}')"
      fi

      if [ -n "$PORTAINER_BASIC_AUTH_USER" ] && [ -n "$PORTAINER_BASIC_AUTH_PASSWORD" ]; then
        if ! docker image inspect httpd:alpine >/dev/null 2>&1; then
          docker pull -q httpd:alpine
        fi
        BASIC_AUTH_HTPASSWD_LINE="$(docker run --rm httpd:alpine htpasswd -Bbn "$PORTAINER_BASIC_AUTH_USER" "$PORTAINER_BASIC_AUTH_PASSWORD" | head -n 1)"
        # docker compose treats '$' as interpolation marker in compose files; escape as '$$'
        BASIC_AUTH_HTPASSWD_LINE_COMPOSE="$(printf '%s' "$BASIC_AUTH_HTPASSWD_LINE" | sed 's/\$/\$\$/g')"

        {
          echo "# Generated by CI (Traefik Basic Auth)"
          echo "services:"
          echo "  portainer:"
          echo "    labels:"
          echo "      - \"traefik.http.routers.${PROJECT_NAME}.middlewares=${PROJECT_NAME}-auth\""
          echo "      - \"traefik.http.middlewares.${PROJECT_NAME}-auth.basicauth.users=${BASIC_AUTH_HTPASSWD_LINE_COMPOSE}\""
        } > docker-compose.override.yml
      else
        # If creds are not set, ensure CI-managed auth is disabled.
        if [ -f docker-compose.override.yml ] && head -n 1 docker-compose.override.yml | grep -q '^# Generated by CI (Traefik Basic Auth)$'; then
          rm -f docker-compose.override.yml
        fi
      fi

      if ! command -v git >/dev/null 2>&1; then
        echo "git is not installed on the server" >&2
        exit 1
      fi

      if ! command -v docker >/dev/null 2>&1; then
        echo "docker is not installed on the server" >&2
        exit 1
      fi

      COMPOSE_BIN="docker compose"
      if ! docker compose version >/dev/null 2>&1; then
        if command -v docker-compose >/dev/null 2>&1; then
          COMPOSE_BIN="docker-compose"
        else
          echo "Docker Compose is not available (neither 'docker compose' nor 'docker-compose')" >&2
          exit 1
        fi
      fi

      clone_url="$REPO_URL"
      if [ -n "${REPO_SSH_KEY_B64:-}" ]; then
        mkdir -p "$HOME/.ssh"
        chmod 700 "$HOME/.ssh"
        key_path="$HOME/.ssh/repo_deploy_key"
        if printf '%s' "$REPO_SSH_KEY_B64" | grep -q '-----BEGIN'; then
          printf '%s\n' "$REPO_SSH_KEY_B64" > "$key_path"
        else
          if ! printf '%s' "$REPO_SSH_KEY_B64" | tr -d '\n\r' | base64 -d 2>/dev/null > "$key_path"; then
            printf '%s\n' "$REPO_SSH_KEY_B64" > "$key_path"
          fi
        fi
        chmod 600 "$key_path"
        touch "$HOME/.ssh/known_hosts"
        chmod 600 "$HOME/.ssh/known_hosts"

        repo_host=""
        case "$REPO_URL" in
          git@*:* ) repo_host="$(printf '%s' "$REPO_URL" | awk -F'[@:]' '{print $2}')" ;;
          https://*/* ) repo_host="$(printf '%s' "$REPO_URL" | awk -F[/:] '{print $4}')" ;;
        esac
        if [ -n "$repo_host" ]; then
          if ! ssh-keygen -F "$repo_host" >/dev/null 2>&1; then
            ssh-keyscan -H "$repo_host" >> "$HOME/.ssh/known_hosts" 2>/dev/null || true
          fi
        fi

        export GIT_SSH_COMMAND="ssh -i $key_path -o IdentitiesOnly=yes -o StrictHostKeyChecking=yes"

        if printf '%s' "$REPO_URL" | grep -q '^https\?://'; then
          repo_host="$(printf '%s' "$REPO_URL" | awk -F[/:] '{print $4}')"
          repo_path="$(printf '%s' "$REPO_URL" | sed -E 's#^https?://[^/]+/##')"
          repo_path="${repo_path%.git}"
          clone_url="git@${repo_host}:${repo_path}.git"
        fi
      fi

      if [ ! -d "$PROJECT_PATH" ]; then
        mkdir -p "$(dirname "$PROJECT_PATH")"
        git clone --branch "$branch" "$clone_url" "$PROJECT_PATH"
      fi

      if [ -d "$PROJECT_PATH" ] && [ ! -d "$PROJECT_PATH/.git" ]; then
        if [ -z "$(ls -A "$PROJECT_PATH" 2>/dev/null || true)" ]; then
          rmdir "$PROJECT_PATH" 2>/dev/null || true
          mkdir -p "$(dirname "$PROJECT_PATH")"
          git clone --branch "$branch" "$clone_url" "$PROJECT_PATH"
        else
          echo "Not a git repository: $PROJECT_PATH (missing .git)" >&2
          exit 1
        fi
      fi

      cd "$PROJECT_PATH"

      if [ ! -f docker-compose.yml ]; then
        echo "docker-compose.yml not found in $PROJECT_PATH" >&2
        exit 1
      fi

      git remote set-url origin "$clone_url" || true
      if ! git pull origin "$branch"; then
        echo "git pull failed. If this is a private repository, set REPO_SSH_KEY in GitLab CI variables." >&2
        exit 1
      fi

      if ! docker network inspect "$TRAEFIK_NETWORK" >/dev/null 2>&1; then
        echo "Traefik network '$TRAEFIK_NETWORK' does not exist on the server" >&2
        exit 1
      fi

      tmp="$(mktemp)"
      if [ -f .env ]; then
        grep -vE '^(PROJECT_NAME|DOMAIN_NAME|TRAEFIK_NETWORK|TRAEFIK_ENTRYPOINT)=' .env > "$tmp" || true
      fi

      : > .env
      printf '%s\n' "PROJECT_NAME=$PROJECT_NAME" >> .env
      printf '%s\n' "DOMAIN_NAME=$DOMAIN_NAME" >> .env
      printf '%s\n' "TRAEFIK_NETWORK=$TRAEFIK_NETWORK" >> .env
      if [ -n "$TRAEFIK_ENTRYPOINT" ]; then
        printf '%s\n' "TRAEFIK_ENTRYPOINT=$TRAEFIK_ENTRYPOINT" >> .env
      fi
      if [ -s "$tmp" ]; then cat "$tmp" >> .env; fi
      rm -f "$tmp"

      $COMPOSE_BIN up -d
      docker image prune -f
      REMOTE
